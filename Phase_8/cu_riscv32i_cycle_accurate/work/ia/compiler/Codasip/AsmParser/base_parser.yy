/**
 * Codasip s.r.o.
 *
 * CONFIDENTIAL
 *
 * Copyright 2019 Codasip s.r.o.
 *
 * All Rights Reserved.
 *
 * NOTICE: All information contained in this file, is and shall remain the property of
 * Codasip s.r.o. and its suppliers, if any.
 *
 * The intellectual and technical concepts contained herein are confidential and proprietary to
 * Codasip s.r.o. and are protected by trade secret and copyright law.  In addition, elements of the
 * technical concepts may be patent pending.
 *
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 */

/**
 *  \brief Base of syntactic analyzer for assembly code generated by msp-gcc compiler.
 * 
 *         Instruction set information is generated automatically,
 *         this file describes mainly directives, label and constants formats.
 */
 
// reentrant parser
%define api.pure true
// pass arguments to both flex and bison
%param { yyscan_t scanner }
%parse-param { llvm::MCAsmParser& parser }
%parse-param { const llvm::SMLoc& base }
%parse-param { codasip::ast::assembler::Node*& ast }
%initial-action
{
    // Initialize Codasip lexical analyzer
    InitializeScanner(scanner, parser, base);
    // Initialize first location object
    @$.initialize();
};

%code requires {
    #include "instrset/assembler/asmbasel/ast/assembler/node.h"
    #include "llvm/MC/MCParser/MCAsmParser.h"

    // reentrant parser
    typedef void* yyscan_t;
    union YYSTYPE;
    struct CODASIP_YYLTYPE
    {
      void initialize()
      {
          first_line = 1;
          first_column = 1;
          last_line = 1;
          last_column = 1;
          first = 0;
          last = 0;
      }
      // First four are useless in Codasip ASM parser for LLVM, present only for compatibility with bison code
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      // Offset of the first character in LLVM buffer
      int first;
      // Offset of the last character in LLVM buffer
      int last;
    };
    #define YYLTYPE struct CODASIP_YYLTYPE
    #define YYLTYPE_IS_DECLARED 1 /* alert the parser that we have our own definition */
    #define YYLLOC_DEFAULT(Current, Rhs, N)                                 \
        do                                                                  \
          if (N)                                                            \
            {                                                               \
              (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \
              (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \
              (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \
              (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \
              (Current).first        = YYRHSLOC (Rhs, 1).first;             \
              (Current).last         = YYRHSLOC (Rhs, N).last;              \
            }                                                               \
          else                                                              \
            {                                                               \
              (Current).first_line   = (Current).last_line   =              \
                YYRHSLOC (Rhs, 0).last_line;                                \
              (Current).first_column = (Current).last_column =              \
                YYRHSLOC (Rhs, 0).last_column;                              \
              (Current).first        = (Current).last =                     \
                YYRHSLOC (Rhs, 0).last;                                     \
            }                                                               \
        while (0)
    #define YY_DECL \
        extern "C" int yylex(YYSTYPE* yylval_param, YYLTYPE* yylloc_param, yyscan_t yyscanner)
    YY_DECL;
    extern "C" void InitializeScanner(yyscan_t scanner, llvm::MCAsmParser& parser, const llvm::SMLoc& base);
    int yyerror(YYLTYPE* loc, yyscan_t scanner, llvm::MCAsmParser& parser, const llvm::SMLoc& base, codasip::ast::assembler::Node*& ast, const char* msg);
}

%{
#ifndef ASSEMBLER_BASE_SCANNER_H_
#define ASSEMBLER_BASE_SCANNER_H_

#define YYDEBUG 1
#define YYMAXDEPTH 2000000

#include <cstdlib>
#include <cstring>
#include <errno.h>
#include <string>

#include "utility/codasip_log.h"
#include "utility/codasiputils.h"

#include "instrset/assembler/asmbasel/ast/assembler/builder.h"
#include "instrset/assembler/asmbasel/parser_utility.h"

using namespace codasip;
using namespace codasip::assembler;

extern filesystem::Path inputFileName;

#endif  // ASSEMBLER_BASE_SCANNER_H_
%}

%union
{
    std::string* text;
    char character;
    codasip::ast::assembler::Node* assemblerNode;
    int num;
}

/*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*/
/*------------------------------------ start of user-modifiable section --------------------------*/
/*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*/

// tokens - all tokens must have set fixed value,
// because we need to be sure, that generated tokens do not collide
%token <text> UNICODE_LETTER "unicode letter"
%token <text> UNICODE_MARK "unicode mark"
%token <text> UNICODE_NUMBER "unicode number"
%token <text> STRING "string"

// single character tokens
%token <character> A "a"
%token <character> B "b"
%token <character> C "c"
%token <character> D "d"
%token <character> E "e"
%token <character> F "f"
%token <character> G "g"
%token <character> H "h"
%token <character> I "i"
%token <character> J "j"
%token <character> K "k"
%token <character> L "l"
%token <character> M "m"
%token <character> N "n"
%token <character> O "o"
%token <character> P "p"
%token <character> Q "q"
%token <character> R "r"
%token <character> S "s"
%token <character> T "t"
%token <character> U "u"
%token <character> V "v"
%token <character> W "w"
%token <character> X "x"
%token <character> Y "y"
%token <character> Z "z"

%type <text> BinaryConstantCore OctalConstantCore DecimalConstantCore HexadecimalConstantCore
%type <text> IdentifierTop IdentifierStart IdentifierPart SymbolPrefix
%type <character> Alpha AlphaNumber BinaryDigit OctalDigit DecimalDigit HexadecimalDigit
%type <character> MaybeCharEscape CharLiteralCore MaybeCharEnd
%type <assemblerNode> Program Code
%type <assemblerNode> IntegerConstant BinaryConstant OctalConstant DecimalConstant HexadecimalConstant
%type <assemblerNode> CharLiteral Identifier String SymbolIdentifier
%type <assemblerNode> Attribute Expression1 Expression2 Expression3
%type <assemblerNode> Expression4 Expression5 Expression6 Expression7 Expression8
%type <assemblerNode> Expression9 Expression10 Expression11 Expression12 Expression13
%type <assemblerNode> ConstantAttribute ConstantExpression1
%type <assemblerNode> ConstantExpression2 ConstantExpression3 ConstantExpression4 
%type <assemblerNode> ConstantExpression5 ConstantExpression6 ConstantExpression7
%type <assemblerNode> ConstantExpression8 ConstantExpression9 ConstantExpression10
%type <assemblerNode> ConstantExpression11 ConstantExpression12 ConstantExpression13
%type <num> MaybeNewlines MWS WS

%debug
%defines
%error-verbose
%glr-parser
%locations

%start Start

%code {
/**
 * \brief Return location in the current parsed source
 */
static Location GetLocation(YYLTYPE location);
ast::assembler::Node* MergeNode(YYSTYPE x1, YYSTYPE x2);
ast::assembler::Node* MergeConditionalSections(YYSTYPE x1, YYSTYPE x2);
ast::assembler::Node* MergeCode(YYSTYPE x1, YYSTYPE x2);
}

%%

Start
    : Program
    {
        ast = $1;
        YYACCEPT;
    }
    ;

// Starting nonterminal.
// In file generated from instruction set grammar is also present a rule that provides substitution
// of instruction set grammar generated strings into complete assembler source file language.
Program
    : Code MWS Newline
    ;

SymbolIdentifier
    : Identifier
    | String
    ;

Attribute
    : Expression1
    ;

// should not be solved by usage of %left and %right, because of presence of MWS non-terminals
Expression1
    : Expression2 MWS '?' MWS Expression1 MWS ':' MWS Expression1
    {
        $$ = &ast::assembler::Builder::CreateTernary(GetLocation(@3), "?:", *$1, *$5, *$9, $2 + $4 + $6 + $8);
    }
    | Expression2
    ;

Expression2
    : Expression2 MWS '|' '|' MWS Expression3
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "||", *$1, *$6, $2 + $5);
    }
    | Expression3
    ;

Expression3
    : Expression3 MWS '&' '&' MWS Expression4
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "&&", *$1, *$6, $2 + $5);
    }
    | Expression4
    ;

Expression4
    : Expression4 MWS '|' MWS Expression5
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "|", *$1, *$5, $2 + $4);
    }
    | Expression5
    ;

Expression5
    : Expression5 MWS '^' MWS Expression6
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "^", *$1, *$5, $2 + $4);
    }
    | Expression6
    ;

Expression6
    : Expression6 MWS '&' MWS Expression7
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "&", *$1, *$5, $2 + $4);
    }
    | Expression7
    ;

Expression7
    : Expression7 MWS '=' '=' MWS Expression8
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "==", *$1, *$6, $2 + $5);
    }
    | Expression7 MWS '!' '=' MWS Expression8
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "!=", *$1, *$6, $2 + $5);
    }
    | Expression8
    ;

Expression8
    : Expression8 MWS '<' MWS Expression9
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "<", *$1, *$5, $2 + $4);
    }
    | Expression8 MWS '<' '=' MWS Expression9
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "<=", *$1, *$6, $2 + $5);
    }
    | Expression8 MWS '>' MWS Expression9
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), ">", *$1, *$5, $2 + $4);
    }
    | Expression8 MWS '>' '=' MWS Expression9
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), ">=", *$1, *$6, $2 + $5);
    }
    | Expression9
    ;

Expression9
    : Expression9 MWS '<' '<' MWS Expression10
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "<<", *$1, *$6, $2 + $5);
    }
    | Expression9 MWS '>' '>' MWS Expression10
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), ">>", *$1, *$6, $2 + $5);
    }
    | Expression10
    ;

Expression10
    : Expression10 MWS '+' MWS Expression11
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "+", *$1, *$5, $2 + $4);
    }
    | Expression10 MWS '-' MWS Expression11
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "-", *$1, *$5, $2 + $4);
    }
    | Expression11
    ;

Expression11
    : Expression11 MWS '*' MWS Expression12
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "*", *$1, *$5, $2 + $4);
    }
    | Expression11 MWS '/' MWS Expression12
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "/", *$1, *$5, $2 + $4);
    }
    | Expression11 MWS '%' MWS Expression12
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "%", *$1, *$5, $2 + $4);
    }
    | Expression12
    ;

Expression12
    : '+' MWS Expression13
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "+", *$3, $2);
    }
    | '-' MWS Expression13
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "-", *$3, $2);
    }
    | '~' MWS Expression13
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "~", *$3, $2);
    }
    | '!' MWS Expression13
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "!", *$3, $2);
    }
    | Expression13
    ;

// Expressions: parentheses, constants and identifiers.
Expression13
    : IntegerConstant
    | SymbolIdentifier
    | '(' MWS Expression1 MWS ')'
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "()", *$3, $2 + $4);
    }
    ;

ConstantAttribute
    : ConstantExpression1
    ;

// should not be solved by usage of %left and %right, because of presence of MWS non-terminals
ConstantExpression1
    : ConstantExpression2 MWS '?' MWS ConstantExpression1 MWS ':' MWS ConstantExpression1
    {
        $$ = &ast::assembler::Builder::CreateTernary(GetLocation(@3), "?:", *$1, *$5, *$9, $2 + $4 + $6 + $8);
    }
    | ConstantExpression2
    ;

ConstantExpression2
    : ConstantExpression2 MWS '|' '|' MWS ConstantExpression3
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "||", *$1, *$6, $2 + $5);
    }
    | ConstantExpression3
    ;

ConstantExpression3
    : ConstantExpression3 MWS '&' '&' MWS ConstantExpression4
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "&&", *$1, *$6, $2 + $5);
    }
    | ConstantExpression4
    ;

ConstantExpression4
    : ConstantExpression4 MWS '|' MWS ConstantExpression5
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "|", *$1, *$5, $2 + $4);
    }
    | ConstantExpression5
    ;

ConstantExpression5
    : ConstantExpression5 MWS '^' MWS ConstantExpression6
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "^", *$1, *$5, $2 + $4);
    }
    | ConstantExpression6
    ;

ConstantExpression6
    : ConstantExpression6 MWS '&' MWS ConstantExpression7
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "&", *$1, *$5, $2 + $4);
    }
    | ConstantExpression7
    ;

ConstantExpression7
    : ConstantExpression7 MWS '=' '=' MWS ConstantExpression8
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "==", *$1, *$6, $2 + $5);
    }
    | ConstantExpression7 MWS '!' '=' MWS ConstantExpression8
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "!=", *$1, *$6, $2 + $5);
    }
    | ConstantExpression8
    ;

ConstantExpression8
    : ConstantExpression8 MWS '<' MWS ConstantExpression9
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "<", *$1, *$5, $2 + $4);
    }
    | ConstantExpression8 MWS '<' '=' MWS ConstantExpression9
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "<=", *$1, *$6, $2 + $5);
    }
    | ConstantExpression8 MWS '>' MWS ConstantExpression9
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), ">", *$1, *$5, $2 + $4);
    }
    | ConstantExpression8 MWS '>' '=' MWS ConstantExpression9
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), ">=", *$1, *$6, $2 + $5);
    }
    | ConstantExpression9
    ;

ConstantExpression9
    : ConstantExpression9 MWS '<' '<' MWS ConstantExpression10
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "<<", *$1, *$6, $2 + $5);
    }
    | ConstantExpression9 MWS '>' '>' MWS ConstantExpression10
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), ">>", *$1, *$6, $2 + $5);
    }
    | ConstantExpression10
    ;

ConstantExpression10
    : ConstantExpression10 MWS '+' MWS ConstantExpression11
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "+", *$1, *$5, $2 + $4);
    }
    | ConstantExpression10 MWS '-' MWS ConstantExpression11
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "-", *$1, *$5, $2 + $4);
    }
    | ConstantExpression11
    ;

ConstantExpression11
    : ConstantExpression11 MWS '*' MWS ConstantExpression12
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "*", *$1, *$5, $2 + $4);
    }
    | ConstantExpression11 MWS '/' MWS ConstantExpression12
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "/", *$1, *$5, $2 + $4);
    }
    | ConstantExpression11 MWS '%' MWS ConstantExpression12
    {
        $$ = &ast::assembler::Builder::CreateBinary(GetLocation(@3), "%", *$1, *$5, $2 + $4);
    }
    | ConstantExpression12
    ;

ConstantExpression12
    : '+' MWS ConstantExpression13
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "+", *$3, $2);
    }
    | '-' MWS ConstantExpression13
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "-", *$3, $2);
    }
    | '~' MWS ConstantExpression13
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "~", *$3, $2);
    }
    | '!' MWS ConstantExpression13
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "!", *$3, $2);
    }
    | ConstantExpression13
    ;

// Constant expressions: parentheses and constants.
ConstantExpression13
    : IntegerConstant
    | '(' MWS ConstantExpression1 MWS ')'
    {
        $$ = &ast::assembler::Builder::CreateUnary(GetLocation(@1), "()", *$3, $2 + $4);
    }
    ;

// Simple rule that transforms read ID to token structure.
// Returns Token*.
Identifier
    : IdentifierTop
    {
        $$ = &ast::assembler::Builder::CreateIdentifier(GetLocation(@1), *$1);
        delete $1;
    }
    ;

IdentifierTop
    : IdentifierStart IdentifierPart
    {
        $$ = new std::string();
        *$$ += *$1;
        *$$ += *$2;
        delete $1;
        delete $2;
    }
    | DecimalConstantCore B
    {
        $$ = $1;
        *$$ += $2;
    }
    | DecimalConstantCore F
    {
        $$ = $1;
        *$$ += $2;
    }
    ;

IdentifierStart
    : Alpha
    {
        $$ = new std::string();
        *$$ += $1;
    }
    | '_'
    {
        $$ = new std::string("_");
    }
    | '.'
    {
        $$ = new std::string(".");
    }
    | '$'
    {
        $$ = new std::string("$");
    }
    | UNICODE_LETTER
    | UNICODE_MARK
    ;

IdentifierPart
    : IdentifierPart AlphaNumber
    {
        $$ = $1;
        *$$ += $2;
    }
    | IdentifierPart '_'
    {
        $$ = $1;
        *$$ += "_";
    }
    | IdentifierPart '.'
    {
        $$ = $1;
        *$$ += ".";
    }
    | IdentifierPart '$'
    {
        $$ = $1;
        *$$ += "$";
    }
    | IdentifierPart UNICODE_LETTER
    {
        $$ = $1;
        *$$ += *$2;
    }
    | IdentifierPart UNICODE_MARK
    {
        $$ = $1;
        *$$ += *$2;
    }
    | IdentifierPart UNICODE_NUMBER
    {
        $$ = $1;
        *$$ += *$2;
    }
    | // empty
    {
        $$ = new std::string();
    }
    ;

// Simple rule that transforms read string to token structure.
// Value of attribute of this nonterminal is a token with string attribute.
String
    : STRING
    {
        $$ = &ast::assembler::Builder::CreateString(GetLocation(@1), *$1);
        delete $1;
    }
    ;

// Nonterminal IntegerConstant represents constant number used in assembler source file.
// Returns Token*.
IntegerConstant
    : BinaryConstant
    | OctalConstant
    | DecimalConstant
    | HexadecimalConstant
    | CharLiteral
    ;

BinaryConstant
    : '0' B BinaryConstantCore
    {
        std::string s = "0";
        s += $2;
        s += *$3;
        $$ = &ParserUtility::ConvertConstantToToken(GetLocation(@1), s, 2, 2, "binary");
        delete $3;
    }
    ;

OctalConstant
    : '0' OctalConstantCore
    {
        std::string s = "0";
        s += *$2;
        $$ = &ParserUtility::ConvertConstantToToken(GetLocation(@1), s, 1, 8, "octal");
        delete $2;
    }
    ;

DecimalConstant
    : DecimalConstantCore
    {
        $$ = &ParserUtility::ConvertConstantToToken(GetLocation(@1), *$1, 0, 10, "decimal");
        delete $1;
    }
    ;

HexadecimalConstant
    : '0' X HexadecimalConstantCore
    {
        std::string s = "0";
        s += $2;
        s += *$3;
        $$ = &ParserUtility::ConvertConstantToToken(GetLocation(@1), s, 2, 16, "hexadecimal");
        delete $3;
    }
    ;

CharLiteral
    : '\'' MaybeCharEscape CharLiteralCore MaybeCharEnd
    {
        std::string s = "'";
        if ($2 != '\0')
        {
            s += $2;
        }
        s += $3;
        if ($4 != '\0')
        {
            s += $4;
        }
        $$ = &ParserUtility::ConvertConstantToToken(GetLocation(@1), s, 1, 0, "character");
    }
    ;

MaybeCharEscape
    : // empty
    {
        $$ = '\0';
    }
    | '\\'
    {
        $$ = '\\';
    }
    ;

MaybeCharEnd
    : // empty
    {
        $$ = '\0';
    }
    | '\''
    {
        $$ = '\'';
    }
    ;

BinaryConstantCore
    : BinaryConstantCore BinaryDigit
    {
        $$ = $1;
        *$$ += $2;
    }
    | BinaryDigit
    {
        $$ = new std::string();
        *$$ += $1;
    }
    ;

OctalConstantCore
    : OctalConstantCore OctalDigit
    {
        $$ = $1;
        *$$ += $2;
    }
    | OctalDigit
    {
        $$ = new std::string();
        *$$ += $1;
    }
    ;

DecimalConstantCore
    : DecimalConstantCore DecimalDigit
    {
        $$ = $1;
        *$$ += $2;
    }
    | DecimalDigit
    {
        $$ = new std::string();
        *$$ += $1;
    }
    ;

HexadecimalConstantCore
    : HexadecimalConstantCore HexadecimalDigit
    {
        $$ = $1;
        *$$ += $2;
    }
    | HexadecimalDigit
    {
        $$ = new std::string();
        *$$ += $1;
    }
    ;

CharLiteralCore
    : AlphaNumber
    | '\t' { $$ = '\t'; }
    | '\n' { $$ = '\n'; }
    | '\r' { $$ = '\r'; }
    | ' '  { $$ = ' '; }
    | '!'  { $$ = '!'; }
    | '"'  { $$ = '"'; }
    | '#'  { $$ = '#'; }
    | '$'  { $$ = '$'; }
    | '%'  { $$ = '%'; }
    | '&'  { $$ = '&'; }
    | '\'' { $$ = '\''; }
    | '('  { $$ = '('; }
    | ')'  { $$ = ')'; }
    | '*'  { $$ = '*'; }
    | '+'  { $$ = '+'; }
    | ','  { $$ = ','; }
    | '-'  { $$ = '-'; }
    | '.'  { $$ = '.'; }
    | '/'  { $$ = '/'; }
    | ':'  { $$ = ':'; }
    | ';'  { $$ = ';'; }
    | '<'  { $$ = '<'; }
    | '='  { $$ = '='; }
    | '>'  { $$ = '>'; }
    | '?'  { $$ = '?'; }
    | '@'  { $$ = '@'; }
    | '['  { $$ = '['; }
    | '\\' { $$ = '\\'; }
    | ']'  { $$ = ']'; }
    | '^'  { $$ = '^'; }
    | '_'  { $$ = '_'; }
    | '`'  { $$ = '`'; }
    | '{'  { $$ = '{'; }
    | '|'  { $$ = '|'; }
    | '}'  { $$ = '}'; }
    | '~'  { $$ = '~'; }
    ;

AlphaNumber
    : DecimalDigit
    | Alpha
    ;

BinaryDigit
    : '0' { $$ = '0'; }
    | '1' { $$ = '1'; }
    ;

OctalDigit
    : '0' { $$ = '0'; }
    | '1' { $$ = '1'; }
    | '2' { $$ = '2'; }
    | '3' { $$ = '3'; }
    | '4' { $$ = '4'; }
    | '5' { $$ = '5'; }
    | '6' { $$ = '6'; }
    | '7' { $$ = '7'; }
    ;

DecimalDigit
    : '0' { $$ = '0'; }
    | '1' { $$ = '1'; }
    | '2' { $$ = '2'; }
    | '3' { $$ = '3'; }
    | '4' { $$ = '4'; }
    | '5' { $$ = '5'; }
    | '6' { $$ = '6'; }
    | '7' { $$ = '7'; }
    | '8' { $$ = '8'; }
    | '9' { $$ = '9'; }
    ;

HexadecimalDigit
    : '0' { $$ = '0'; }
    | '1' { $$ = '1'; }
    | '2' { $$ = '2'; }
    | '3' { $$ = '3'; }
    | '4' { $$ = '4'; }
    | '5' { $$ = '5'; }
    | '6' { $$ = '6'; }
    | '7' { $$ = '7'; }
    | '8' { $$ = '8'; }
    | '9' { $$ = '9'; }
    | A
    | B
    | C
    | D
    | E
    | F
    ;

Alpha
    : A
    | B
    | C
    | D
    | E
    | F
    | G
    | H
    | I
    | J
    | K
    | L
    | M
    | N
    | O
    | P
    | Q
    | R
    | S
    | T
    | U
    | V
    | W
    | X
    | Y
    | Z
    ;

// Used mainly for VLIW architectures to be able to skip comments inside a bundle.
// Represents at least one newline.
MaybeNewlines
    : Newline
    {
        $$ = 1;
    }
    | MaybeNewlines MWS Newline
    {
        $$ = $1 + $2 + 1;
    }
    ;

Newline
    : '\n'
    ;

MWS
    : // empty
    {
        $$ = 0;
    }
    | WS
    ;

WS
    : WS WSChar
    {
        $$ = $1 + 1;
    }
    | WSChar
    {
        $$ = 1;
    }
    ;

WSChar
    : ' '
    | '\t'
    | '\r'
    ;

%%

/*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*/
/*---------------------------------- end of user-modifiable section ------------------------------*/
/*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*/

/**
 * \brief This function is called when syntactic error was encountered.
 * \param[in] s message
 */
int yyerror(YYLTYPE* location, yyscan_t, llvm::MCAsmParser& parser, const llvm::SMLoc& base, codasip::ast::assembler::Node*&, const char* s)
{
    llvm::SMLoc S = llvm::SMLoc::getFromPointer(base.getPointer() + location->first);
    return parser.Error(S, "Syntactic analysis error: " + std::string(s) + ".");
}

static Location GetLocation(YYLTYPE location)
{
    // Location is used as offset into LLVM buffer
    return Location(inputFileName, location.first, location.last);
}

/**
 * \brief Handle ambiguity by matching two AST. AST with less Attribute nodes is returned.
 * \param[in] x1 first AST
 * \param[in] x2 second AST
 */
ast::assembler::Node* MergeNode(YYSTYPE x1, YYSTYPE x2)
{
    return ParserUtility::MergeNode(x1.assemblerNode, x2.assemblerNode);
}

/**
 *  \brief  Handle ambiguity by matching two conditional sections.
 *  \param[in]  x1 first AST
 *  \param[in]  x2 second AST
 */
ast::assembler::Node* MergeConditionalSections(YYSTYPE x1, YYSTYPE x2)
{
    return ParserUtility::MergeConditionalSections(x1.assemblerNode, x2.assemblerNode);
}

/**
 * \brief Handle ambiguity by matching two parser commands.
 *        GenerateInstructionCommand is returned. Other is deleted.
 * \param[in] x1 first command
 * \param[in] x1 second command
 */
ast::assembler::Node* MergeCode(YYSTYPE x1, YYSTYPE x2)
{
    return ParserUtility::MergeCode(x1.assemblerNode, x2.assemblerNode);
}
