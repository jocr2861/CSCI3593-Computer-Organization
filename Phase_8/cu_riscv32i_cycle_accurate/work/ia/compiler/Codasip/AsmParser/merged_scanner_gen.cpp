// merged_scanner_gen.cpp generated by reflex 1.2.0 from merged_scanner_gen.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_array               true
#define REFLEX_OPTION_bison               true
#define REFLEX_OPTION_bison_bridge        true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_case_insensitive    true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_header_file         "merged_scanner_gen.hpp"
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_nowarn              true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "merged_scanner_gen.cpp"
#define REFLEX_OPTION_prefix              yy
#define REFLEX_OPTION_reentrant           true
#define REFLEX_OPTION_stack               true
#define REFLEX_OPTION_yyclass             CodasipLexer
#define REFLEX_OPTION_yylineno            true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 65 "merged_scanner_gen.l"

    #include "merged_parser_gen.hpp"
    #define YY_EXTERN_C extern "C"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define YY_NUM_RULES (78)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {
 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {
  }
  virtual void yylloc_update(YYLTYPE& yylloc)
  {
    yylloc.first_line = matcher().lineno();
    yylloc.first_column = matcher().columno();
    yylloc.last_line = yylloc.first_line + matcher().lines() - 1;
    yylloc.last_column = yylloc.first_column + matcher().columns() - 1;
  }
  virtual int yylex(void)
  {
    LexerError("yyFlexLexer::yylex invoked but %option bison-bridge and/or bison-locations is used");
    yyterminate();
  }
  virtual int yylex(YYSTYPE& yylval, YYLTYPE& yylloc)
  {
    LexerError("yyFlexLexer::yylex invoked but %option yyclass=CodasipLexer is used");
    yyterminate();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "merged_scanner_gen.l"
/**
 * Codasip s.r.o.
 *
 * CONFIDENTIAL
 *
 * Copyright 2022 Codasip s.r.o.
 *
 * All Rights Reserved.
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 *
 * \file
 * \date    2022-11-20
 * \author  Codasip (c) Assembler generator
 * \version 9.1.1-1255
 * \brief   Source for assembler
 */

#line 20 "merged_scanner_gen.l"
/**
 * Codasip s.r.o.
 *
 * CONFIDENTIAL
 *
 * Copyright 2022 Codasip s.r.o.
 *
 * All Rights Reserved.
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 *
 * \file
 * \date    2022-11-20
 * \author  Codasip (c) Assembler generator
 * \version 9.1.1-1255
 * \brief   Source for assembler
 */

#ifdef _WIN32
#define YY_NO_UNISTD_H
#include <io.h>
#endif

#include <map>
#include <string>
#include <vector>

#include "os/filesysteml/codasip_io.h"
#include "utility/check_condition.h"
#include "utility/codasip_log.h"
#include "utility/number_cast.h"

#include "instrset/assembler/asmbasel/parser_utility.h"

codasip::fs::Path inputFileName;

extern int yydebug;
#define yyfilename inputFileName
#define RETURN(x) return(x)

using namespace codasip::assembler;



#line 78 "merged_scanner_gen.l"

    class CodasipLexer : public yyFlexLexer
    {
    public:
        CodasipLexer(llvm::MCAsmParser* parser = nullptr, const llvm::SMLoc& base = llvm::SMLoc())
          : m_Parser(parser),
            m_Base(base)
        {}
        void Initialize(llvm::MCAsmParser& parser, const llvm::SMLoc& base)
        {
            m_Parser = &parser;
            m_Base = base;
        }
        int yylex(YYSTYPE& yylval, YYLTYPE& yylloc) override;
        void yylloc_update(YYLTYPE& yylloc) override
        {
            yyFlexLexer::yylloc_update(yylloc);
            yylloc.first = matcher().first();
            yylloc.last = matcher().last();
        }

    private:
        /// LLVM MC ASM parser
        llvm::MCAsmParser* m_Parser;
        /// Base location of the LLVM buffer
        llvm::SMLoc m_Base;
        /// Determines whether EOF was already read
        bool m_EofRead = false;
    };


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON BRIDGE LOCATIONS                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON BRIDGE                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

typedef CodasipLexer yyscanner_t;

typedef void *yyscan_t;

#ifndef YY_EXTERN_C
#define YY_EXTERN_C
#endif

YY_EXTERN_C int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner)
{
  return static_cast<yyscanner_t*>(scanner)->yylex(*lvalp, *llocp);
}

YY_EXTERN_C void yylex_init(yyscan_t *scanner)
{
  *scanner = static_cast<yyscan_t>(new yyscanner_t);
}

YY_EXTERN_C void yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *scanner)
{
  *scanner = static_cast<yyscan_t>(new yyscanner_t);
  yyset_extra(extra, *scanner);
}

YY_EXTERN_C void yylex_destroy(yyscan_t scanner)
{
  delete static_cast<yyscanner_t*>(scanner);
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

extern void reflex_code_INITIAL(reflex::Matcher&);

int CodasipLexer::yylex(YYSTYPE& yylval, YYLTYPE& yylloc)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  while (true)
  {
        matcher().scan();
        yylloc_update(yylloc);
        switch (matcher().accept())
        {
          case 0:
            if (matcher().at_end())
            {
#line 201 "merged_scanner_gen.l"
{
    if (m_EofRead)
    {
        RETURN(EOF);
    }
    else
    {
        m_EofRead = true;
        RETURN('\n');
    }
}

            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule at line 115: [_]
            YY_USER_ACTION
#line 115 "merged_scanner_gen.l"
{ RETURN('_'); }
            YY_BREAK
          case 2: // rule at line 116: [\x24]
            YY_USER_ACTION
#line 116 "merged_scanner_gen.l"
{ RETURN('$'); }
            YY_BREAK
          case 3: // rule at line 117: [@]
            YY_USER_ACTION
#line 117 "merged_scanner_gen.l"
{ RETURN('@'); }
            YY_BREAK
          case 4: // rule at line 118: [#]
            YY_USER_ACTION
#line 118 "merged_scanner_gen.l"
{ RETURN('#'); }
            YY_BREAK
          case 5: // rule at line 119: [\x7b]
            YY_USER_ACTION
#line 119 "merged_scanner_gen.l"
{ RETURN('{'); }
            YY_BREAK
          case 6: // rule at line 120: [\x7d]
            YY_USER_ACTION
#line 120 "merged_scanner_gen.l"
{ RETURN('}'); }
            YY_BREAK
          case 7: // rule at line 121: ["]
            YY_USER_ACTION
#line 121 "merged_scanner_gen.l"
{ RETURN('\"'); }
            YY_BREAK
          case 8: // rule at line 122: [']
            YY_USER_ACTION
#line 122 "merged_scanner_gen.l"
{ RETURN('\''); }
            YY_BREAK
          case 9: // rule at line 123: [\x5c]
            YY_USER_ACTION
#line 123 "merged_scanner_gen.l"
{ RETURN('\\'); }
            YY_BREAK
          case 10: // rule at line 124: [`]
            YY_USER_ACTION
#line 124 "merged_scanner_gen.l"
{ RETURN('`'); }
            YY_BREAK
          case 11: // rule at line 125: [\x7c]
            YY_USER_ACTION
#line 125 "merged_scanner_gen.l"
{ RETURN('|'); }
            YY_BREAK
          case 12: // rule at line 126: [&]
            YY_USER_ACTION
#line 126 "merged_scanner_gen.l"
{ RETURN('&'); }
            YY_BREAK
          case 13: // rule at line 127: [\x5c\x5e]
            YY_USER_ACTION
#line 127 "merged_scanner_gen.l"
{ RETURN('^'); }
            YY_BREAK
          case 14: // rule at line 128: [:]
            YY_USER_ACTION
#line 128 "merged_scanner_gen.l"
{ RETURN(':'); }
            YY_BREAK
          case 15: // rule at line 129: [,]
            YY_USER_ACTION
#line 129 "merged_scanner_gen.l"
{ RETURN(','); }
            YY_BREAK
          case 16: // rule at line 130: [\x28]
            YY_USER_ACTION
#line 130 "merged_scanner_gen.l"
{ RETURN('('); }
            YY_BREAK
          case 17: // rule at line 131: [\x29]
            YY_USER_ACTION
#line 131 "merged_scanner_gen.l"
{ RETURN(')'); }
            YY_BREAK
          case 18: // rule at line 132: [\x5b]
            YY_USER_ACTION
#line 132 "merged_scanner_gen.l"
{ RETURN('['); }
            YY_BREAK
          case 19: // rule at line 133: [\x5d]
            YY_USER_ACTION
#line 133 "merged_scanner_gen.l"
{ RETURN(']'); }
            YY_BREAK
          case 20: // rule at line 134: [\x2e]
            YY_USER_ACTION
#line 134 "merged_scanner_gen.l"
{ RETURN('.'); }
            YY_BREAK
          case 21: // rule at line 135: [\x7e]
            YY_USER_ACTION
#line 135 "merged_scanner_gen.l"
{ RETURN('~'); }
            YY_BREAK
          case 22: // rule at line 136: [\x2d]
            YY_USER_ACTION
#line 136 "merged_scanner_gen.l"
{ RETURN('-'); }
            YY_BREAK
          case 23: // rule at line 137: [\x2b]
            YY_USER_ACTION
#line 137 "merged_scanner_gen.l"
{ RETURN('+'); }
            YY_BREAK
          case 24: // rule at line 138: [\x2a]
            YY_USER_ACTION
#line 138 "merged_scanner_gen.l"
{ RETURN('*'); }
            YY_BREAK
          case 25: // rule at line 139: [/]
            YY_USER_ACTION
#line 139 "merged_scanner_gen.l"
{ RETURN('/'); }
            YY_BREAK
          case 26: // rule at line 140: [%]
            YY_USER_ACTION
#line 140 "merged_scanner_gen.l"
{ RETURN('%'); }
            YY_BREAK
          case 27: // rule at line 141: [<]
            YY_USER_ACTION
#line 141 "merged_scanner_gen.l"
{ RETURN('<'); }
            YY_BREAK
          case 28: // rule at line 142: [>]
            YY_USER_ACTION
#line 142 "merged_scanner_gen.l"
{ RETURN('>'); }
            YY_BREAK
          case 29: // rule at line 143: [!]
            YY_USER_ACTION
#line 143 "merged_scanner_gen.l"
{ RETURN('!'); }
            YY_BREAK
          case 30: // rule at line 144: [\x3f]
            YY_USER_ACTION
#line 144 "merged_scanner_gen.l"
{ RETURN('?'); }
            YY_BREAK
          case 31: // rule at line 145: [;]
            YY_USER_ACTION
#line 145 "merged_scanner_gen.l"
{
    BEGIN(INITIAL);
    RETURN(';');
 }
            YY_BREAK
          case 32: // rule at line 149: [=]
            YY_USER_ACTION
#line 149 "merged_scanner_gen.l"
{ RETURN('='); }
            YY_BREAK
          case 33: // rule at line 150: [\x0a]
            YY_USER_ACTION
#line 150 "merged_scanner_gen.l"
{ RETURN('\n'); }
            YY_BREAK
          case 34: // rule at line 151: [0]
            YY_USER_ACTION
#line 151 "merged_scanner_gen.l"
{ RETURN('0'); }
            YY_BREAK
          case 35: // rule at line 152: [1]
            YY_USER_ACTION
#line 152 "merged_scanner_gen.l"
{ RETURN('1'); }
            YY_BREAK
          case 36: // rule at line 153: [2]
            YY_USER_ACTION
#line 153 "merged_scanner_gen.l"
{ RETURN('2'); }
            YY_BREAK
          case 37: // rule at line 154: [3]
            YY_USER_ACTION
#line 154 "merged_scanner_gen.l"
{ RETURN('3'); }
            YY_BREAK
          case 38: // rule at line 155: [4]
            YY_USER_ACTION
#line 155 "merged_scanner_gen.l"
{ RETURN('4'); }
            YY_BREAK
          case 39: // rule at line 156: [5]
            YY_USER_ACTION
#line 156 "merged_scanner_gen.l"
{ RETURN('5'); }
            YY_BREAK
          case 40: // rule at line 157: [6]
            YY_USER_ACTION
#line 157 "merged_scanner_gen.l"
{ RETURN('6'); }
            YY_BREAK
          case 41: // rule at line 158: [7]
            YY_USER_ACTION
#line 158 "merged_scanner_gen.l"
{ RETURN('7'); }
            YY_BREAK
          case 42: // rule at line 159: [8]
            YY_USER_ACTION
#line 159 "merged_scanner_gen.l"
{ RETURN('8'); }
            YY_BREAK
          case 43: // rule at line 160: [9]
            YY_USER_ACTION
#line 160 "merged_scanner_gen.l"
{ RETURN('9'); }
            YY_BREAK
          case 44: // rule at line 161: [a]
            YY_USER_ACTION
#line 161 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(A); }
            YY_BREAK
          case 45: // rule at line 162: [b]
            YY_USER_ACTION
#line 162 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(B); }
            YY_BREAK
          case 46: // rule at line 163: [c]
            YY_USER_ACTION
#line 163 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(C); }
            YY_BREAK
          case 47: // rule at line 164: [d]
            YY_USER_ACTION
#line 164 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(D); }
            YY_BREAK
          case 48: // rule at line 165: [e]
            YY_USER_ACTION
#line 165 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(E); }
            YY_BREAK
          case 49: // rule at line 166: [f]
            YY_USER_ACTION
#line 166 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(F); }
            YY_BREAK
          case 50: // rule at line 167: [g]
            YY_USER_ACTION
#line 167 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(G); }
            YY_BREAK
          case 51: // rule at line 168: [h]
            YY_USER_ACTION
#line 168 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(H); }
            YY_BREAK
          case 52: // rule at line 169: [i]
            YY_USER_ACTION
#line 169 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(I); }
            YY_BREAK
          case 53: // rule at line 170: [j]
            YY_USER_ACTION
#line 170 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(J); }
            YY_BREAK
          case 54: // rule at line 171: [k]
            YY_USER_ACTION
#line 171 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(K); }
            YY_BREAK
          case 55: // rule at line 172: [l]
            YY_USER_ACTION
#line 172 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(L); }
            YY_BREAK
          case 56: // rule at line 173: [m]
            YY_USER_ACTION
#line 173 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(M); }
            YY_BREAK
          case 57: // rule at line 174: [n]
            YY_USER_ACTION
#line 174 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(N); }
            YY_BREAK
          case 58: // rule at line 175: [o]
            YY_USER_ACTION
#line 175 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(O); }
            YY_BREAK
          case 59: // rule at line 176: [p]
            YY_USER_ACTION
#line 176 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(P); }
            YY_BREAK
          case 60: // rule at line 177: [q]
            YY_USER_ACTION
#line 177 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(Q); }
            YY_BREAK
          case 61: // rule at line 178: [r]
            YY_USER_ACTION
#line 178 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(R); }
            YY_BREAK
          case 62: // rule at line 179: [s]
            YY_USER_ACTION
#line 179 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(S); }
            YY_BREAK
          case 63: // rule at line 180: [t]
            YY_USER_ACTION
#line 180 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(T); }
            YY_BREAK
          case 64: // rule at line 181: [u]
            YY_USER_ACTION
#line 181 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(U); }
            YY_BREAK
          case 65: // rule at line 182: [v]
            YY_USER_ACTION
#line 182 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(V); }
            YY_BREAK
          case 66: // rule at line 183: [w]
            YY_USER_ACTION
#line 183 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(W); }
            YY_BREAK
          case 67: // rule at line 184: [x]
            YY_USER_ACTION
#line 184 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(X); }
            YY_BREAK
          case 68: // rule at line 185: [y]
            YY_USER_ACTION
#line 185 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(Y); }
            YY_BREAK
          case 69: // rule at line 186: [z]
            YY_USER_ACTION
#line 186 "merged_scanner_gen.l"
{ yylval.character = yytext[0]; RETURN(Z); }
            YY_BREAK
          case 70: // rule at line 187: [\x20]
            YY_USER_ACTION
#line 187 "merged_scanner_gen.l"
{ RETURN(' '); }
            YY_BREAK
          case 71: // rule at line 188: [\x09]
            YY_USER_ACTION
#line 188 "merged_scanner_gen.l"
{ RETURN('\t'); }
            YY_BREAK
          case 72: // rule at line 189: [\x0d]
            YY_USER_ACTION
#line 189 "merged_scanner_gen.l"
{ RETURN('\r'); }

            YY_BREAK
          case 73: // rule at line 191: "(?:\\"|\\\\|\\a|\\b|\\t|\\f|\\n|\\r|'|\\x(?:[0-9A-Fa-f])|\\(?:[0-9])|[^"\x5c])*"
            YY_USER_ACTION
#line 191 "merged_scanner_gen.l"
{
    yylval.text = new std::string(yytext);
    RETURN(STRING);
}

            YY_BREAK
          case 74: // rule at line 196: (?:\Q#\E)[^\x0a]*
            YY_USER_ACTION
#line 196 "merged_scanner_gen.l"
            YY_BREAK
          case 75: // rule at line 197: (?:\Q//\E)[^\x0a]*
            YY_USER_ACTION
#line 197 "merged_scanner_gen.l"


            YY_BREAK
          case 76: // rule at line 199: (?:\Q/*\E)(?:.|\n)*?(?:\Q*/\E)
            YY_USER_ACTION
#line 199 "merged_scanner_gen.l"


            YY_BREAK
          case 77: // rule at line 213: .
            YY_USER_ACTION
#line 213 "merged_scanner_gen.l"
{
    std::stringstream ss;
    ss << "Unexpected character '" << *YY_SCANNER.matcher().begin() << "' (" << std::hex << "0x" << (int)*YY_SCANNER.matcher().begin() << std::dec << ").";
    CHECK_NOT_NULL(m_Parser) << ss.str();
    llvm::SMLoc S = llvm::SMLoc::getFromPointer(m_Base.getPointer() + YY_SCANNER.matcher().first())
;    return m_Parser->Error(S, ss.str());
}

            YY_BREAK
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 222 "merged_scanner_gen.l"


void yyinit(const std::string& filename, yyscan_t scanner)
{
    yyfilename = filename;
}

void SetInputFile(FILE* fin, yyscan_t scanner)
{
    static_cast<yyscanner_t*>(scanner)->in() = fin;
}

void ScanBuffer(const char* buffer, yyscan_t scanner)
{
    yy_scan_string(buffer, scanner);
}

void DeleteCurrentBuffer(yyscan_t scanner)
{
    yy_delete_buffer(static_cast<yyscanner_t*>(scanner)->ptr_matcher(), scanner);
}
void InitializeScanner(yyscan_t scanner, llvm::MCAsmParser& parser, const llvm::SMLoc& base)
{
    static_cast<yyscanner_t*>(scanner)->Initialize(parser, base);
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = c0;
  m.FSM_INIT(c1);

S0:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '~') goto S142;
  if (c1 == '}') goto S110;
  if (c1 == '|') goto S122;
  if (c1 == '{') goto S108;
  if (c1 == 'z') goto S240;
  if (c1 == 'y') goto S238;
  if (c1 == 'x') goto S236;
  if (c1 == 'w') goto S234;
  if (c1 == 'v') goto S232;
  if (c1 == 'u') goto S230;
  if (c1 == 't') goto S228;
  if (c1 == 's') goto S226;
  if (c1 == 'r') goto S224;
  if (c1 == 'q') goto S222;
  if (c1 == 'p') goto S220;
  if (c1 == 'o') goto S218;
  if (c1 == 'n') goto S216;
  if (c1 == 'm') goto S214;
  if (c1 == 'l') goto S212;
  if (c1 == 'k') goto S210;
  if (c1 == 'j') goto S208;
  if (c1 == 'i') goto S206;
  if (c1 == 'h') goto S204;
  if (c1 == 'g') goto S202;
  if (c1 == 'f') goto S200;
  if (c1 == 'e') goto S198;
  if (c1 == 'd') goto S196;
  if (c1 == 'c') goto S194;
  if (c1 == 'b') goto S192;
  if (c1 == '`') goto S120;
  if (c1 == '_') goto S98;
  if (c1 == '^') goto S126;
  if (c1 == ']') goto S138;
  if (c1 == '\\') goto S118;
  if (c1 == '[') goto S136;
  if (c1 == 'Z') goto S240;
  if (c1 == 'Y') goto S238;
  if (c1 == 'X') goto S236;
  if (c1 == 'W') goto S234;
  if (c1 == 'V') goto S232;
  if (c1 == 'U') goto S230;
  if (c1 == 'T') goto S228;
  if (c1 == 'S') goto S226;
  if (c1 == 'R') goto S224;
  if (c1 == 'Q') goto S222;
  if (c1 == 'P') goto S220;
  if (c1 == 'O') goto S218;
  if (c1 == 'N') goto S216;
  if (c1 == 'M') goto S214;
  if (c1 == 'L') goto S212;
  if (c1 == 'K') goto S210;
  if (c1 == 'J') goto S208;
  if (c1 == 'I') goto S206;
  if (c1 == 'H') goto S204;
  if (c1 == 'G') goto S202;
  if (c1 == 'F') goto S200;
  if (c1 == 'E') goto S198;
  if (c1 == 'D') goto S196;
  if (c1 == 'C') goto S194;
  if (c1 == 'B') goto S192;
  if ('A' <= c1 && c1 <= 'a') goto S190;
  if (c1 == '@') goto S102;
  if (c1 == '?') goto S162;
  if (c1 == '>') goto S158;
  if (c1 == '=') goto S166;
  if (c1 == '<') goto S156;
  if (c1 == ';') goto S164;
  if (c1 == ':') goto S128;
  if (c1 == '9') goto S188;
  if (c1 == '8') goto S186;
  if (c1 == '7') goto S184;
  if (c1 == '6') goto S182;
  if (c1 == '5') goto S180;
  if (c1 == '4') goto S178;
  if (c1 == '3') goto S176;
  if (c1 == '2') goto S174;
  if (c1 == '1') goto S172;
  if (c1 == '0') goto S170;
  if (c1 == '/') goto S150;
  if (c1 == '.') goto S140;
  if (c1 == '-') goto S144;
  if (c1 == ',') goto S130;
  if (c1 == '+') goto S146;
  if (c1 == '*') goto S148;
  if (c1 == ')') goto S134;
  if (c1 == '(') goto S132;
  if (c1 == '\'') goto S116;
  if (c1 == '&') goto S124;
  if (c1 == '%') goto S154;
  if (c1 == '$') goto S100;
  if (c1 == '#') goto S104;
  if (c1 == '"') goto S112;
  if (c1 == '!') goto S160;
  if (c1 == ' ') goto S242;
  if (c1 == '\r') goto S246;
  if (c1 == '\n') goto S168;
  if (c1 == '\t') goto S244;
  if ('\0' <= c1) goto S248;
  return m.FSM_HALT(c1);

S98:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S100:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S102:
  m.FSM_TAKE(3);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S104:
  m.FSM_TAKE(4);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S250;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S250;
  return m.FSM_HALT(c1);

S108:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S110:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S112:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S256;
  if (c1 == '"') goto S254;
  if ('\0' <= c1) goto S272;
  return m.FSM_HALT(c1);

S116:
  m.FSM_TAKE(8);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S118:
  m.FSM_TAKE(9);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S120:
  m.FSM_TAKE(10);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S122:
  m.FSM_TAKE(11);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S124:
  m.FSM_TAKE(12);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S126:
  m.FSM_TAKE(13);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S128:
  m.FSM_TAKE(14);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S130:
  m.FSM_TAKE(15);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S132:
  m.FSM_TAKE(16);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S134:
  m.FSM_TAKE(17);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S136:
  m.FSM_TAKE(18);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S138:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S140:
  m.FSM_TAKE(20);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S142:
  m.FSM_TAKE(21);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S144:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S146:
  m.FSM_TAKE(23);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S148:
  m.FSM_TAKE(24);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S150:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '/') goto S275;
  if (c1 == '*') goto S279;
  return m.FSM_HALT(c1);

S154:
  m.FSM_TAKE(26);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S156:
  m.FSM_TAKE(27);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S158:
  m.FSM_TAKE(28);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S160:
  m.FSM_TAKE(29);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S162:
  m.FSM_TAKE(30);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S164:
  m.FSM_TAKE(31);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S166:
  m.FSM_TAKE(32);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S168:
  m.FSM_TAKE(33);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S170:
  m.FSM_TAKE(34);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S172:
  m.FSM_TAKE(35);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S174:
  m.FSM_TAKE(36);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S176:
  m.FSM_TAKE(37);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S178:
  m.FSM_TAKE(38);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S180:
  m.FSM_TAKE(39);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S182:
  m.FSM_TAKE(40);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S184:
  m.FSM_TAKE(41);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S186:
  m.FSM_TAKE(42);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S188:
  m.FSM_TAKE(43);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S190:
  m.FSM_TAKE(44);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S192:
  m.FSM_TAKE(45);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S194:
  m.FSM_TAKE(46);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S196:
  m.FSM_TAKE(47);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S198:
  m.FSM_TAKE(48);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S200:
  m.FSM_TAKE(49);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S202:
  m.FSM_TAKE(50);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S204:
  m.FSM_TAKE(51);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S206:
  m.FSM_TAKE(52);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S208:
  m.FSM_TAKE(53);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S210:
  m.FSM_TAKE(54);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S212:
  m.FSM_TAKE(55);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S214:
  m.FSM_TAKE(56);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S216:
  m.FSM_TAKE(57);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S218:
  m.FSM_TAKE(58);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S220:
  m.FSM_TAKE(59);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S222:
  m.FSM_TAKE(60);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S224:
  m.FSM_TAKE(61);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S226:
  m.FSM_TAKE(62);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S228:
  m.FSM_TAKE(63);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S230:
  m.FSM_TAKE(64);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S232:
  m.FSM_TAKE(65);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S234:
  m.FSM_TAKE(66);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S236:
  m.FSM_TAKE(67);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S238:
  m.FSM_TAKE(68);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S240:
  m.FSM_TAKE(69);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S242:
  m.FSM_TAKE(70);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S244:
  m.FSM_TAKE(71);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S246:
  m.FSM_TAKE(72);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S248:
  m.FSM_TAKE(77);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S250:
  m.FSM_TAKE(74);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S250;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S250;
  return m.FSM_HALT(c1);

S254:
  m.FSM_TAKE(73);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S256:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'x') goto S281;
  if (c1 == 't') goto S272;
  if (c1 == 'r') goto S272;
  if (c1 == 'n') goto S272;
  if (c1 == 'f') goto S272;
  if ('a' <= c1 && c1 <= 'b') goto S272;
  if (c1 == '\\') goto S272;
  if (c1 == 'X') goto S281;
  if (c1 == 'T') goto S272;
  if (c1 == 'R') goto S272;
  if (c1 == 'N') goto S272;
  if (c1 == 'F') goto S272;
  if ('A' <= c1 && c1 <= 'B') goto S272;
  if ('0' <= c1 && c1 <= '9') goto S272;
  if (c1 == '"') goto S272;
  return m.FSM_HALT(c1);

S272:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S256;
  if (c1 == '"') goto S254;
  if ('\0' <= c1) goto S272;
  return m.FSM_HALT(c1);

S275:
  m.FSM_TAKE(75);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S275;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S275;
  return m.FSM_HALT(c1);

S279:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '*') goto S285;
  if ('\0' <= c1) goto S288;
  return m.FSM_HALT(c1);

S281:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'f') goto S272;
  if ('A' <= c1 && c1 <= 'F') goto S272;
  if ('0' <= c1 && c1 <= '9') goto S272;
  return m.FSM_HALT(c1);

S285:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '/') goto S290;
  if (c1 == '*') goto S292;
  if ('\0' <= c1) goto S288;
  return m.FSM_HALT(c1);

S288:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '*') goto S292;
  if ('\0' <= c1) goto S288;
  return m.FSM_HALT(c1);

S290:
  m.FSM_TAKE(76);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S292:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '/') goto S290;
  if (c1 == '*') goto S292;
  if ('\0' <= c1) goto S288;
  return m.FSM_HALT(c1);
}

