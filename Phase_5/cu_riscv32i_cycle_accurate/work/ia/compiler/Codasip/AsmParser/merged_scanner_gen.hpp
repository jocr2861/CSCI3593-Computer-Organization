// merged_scanner_gen.hpp generated by reflex 1.2.0 from merged_scanner_gen.l

#ifndef REFLEX_HEADER_H
#define REFLEX_HEADER_H
#define IN_HEADER 1

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_array               true
#define REFLEX_OPTION_bison               true
#define REFLEX_OPTION_bison_bridge        true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_case_insensitive    true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_header_file         "merged_scanner_gen.hpp"
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_nowarn              true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "merged_scanner_gen.cpp"
#define REFLEX_OPTION_prefix              yy
#define REFLEX_OPTION_reentrant           true
#define REFLEX_OPTION_stack               true
#define REFLEX_OPTION_yyclass             CodasipLexer
#define REFLEX_OPTION_yylineno            true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 65 "merged_scanner_gen.l"

    #include "merged_parser_gen.hpp"
    #define YY_EXTERN_C extern "C"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {
 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {
  }
  virtual void yylloc_update(YYLTYPE& yylloc)
  {
    yylloc.first_line = matcher().lineno();
    yylloc.first_column = matcher().columno();
    yylloc.last_line = yylloc.first_line + matcher().lines() - 1;
    yylloc.last_column = yylloc.first_column + matcher().columns() - 1;
  }
  virtual int yylex(void)
  {
    LexerError("yyFlexLexer::yylex invoked but %option bison-bridge and/or bison-locations is used");
    yyterminate();
  }
  virtual int yylex(YYSTYPE& yylval, YYLTYPE& yylloc)
  {
    LexerError("yyFlexLexer::yylex invoked but %option yyclass=CodasipLexer is used");
    yyterminate();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON BRIDGE LOCATIONS                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

typedef CodasipLexer yyscanner_t;
typedef void *yyscan_t;

#ifndef YY_EXTERN_C
#define YY_EXTERN_C
#endif

YY_EXTERN_C int yylex(YYSTYPE*, YYLTYPE*, yyscan_t);
YY_EXTERN_C void yylex_init(yyscan_t*);
YY_EXTERN_C void yylex_init_extra(YY_EXTRA_TYPE, yyscan_t*);
YY_EXTERN_C void yylex_destroy(yyscan_t);

#endif
