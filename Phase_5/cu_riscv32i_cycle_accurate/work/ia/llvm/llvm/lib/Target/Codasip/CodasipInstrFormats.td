/**
 * Codasip s.r.o.
 *
 * CONFIDENTIAL
 *
 * Copyright 2022 Codasip s.r.o.
 *
 * All Rights Reserved.
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 *
 * \file
 * \date    2022-10-11
 * \author  Codasip (c) C compiler backend generator
 * \version 9.1.1-1255
 * \brief   Source for compiler backend
 * \project cu_riscv32i_cycle_accurate.ia
 * \note          Codasip Studio version: 9.1.1-1255
 *                Licensee: Lockular Limited  (C60_2111_2104)
 *                Project: cu_riscv32i_cycle_accurate.ia
 *                Date: 2022-10-11 05:14:18
 *                Copyright (C) 2022 Codasip s.r.o.
 */


// Definition of symbols used by CodasipInstrInfo.

/// Basic Codasip instruction.
class CodasipInst<dag outs, dag ins>: Instruction
{
  let Namespace = "Codasip";
  let OutOperandList = outs;
  let InOperandList = ins;
  // Predicate info
  string PredSense = "";
  let TSFlags{2} = !if(!eq(PredSense, "false"),1,0);
  bits<1> isPredicated = 0;
  let TSFlags{1} = isPredicated;
  string BaseOpcode = "";
  bits<1> isPredicable = 0;
  bits<1> allowInDelaySlot = 1;
  let TSFlags{3} = allowInDelaySlot;
  let hasCompleteDecoder = 0;
  field bits<32> Inst;
  field bits<32> SoftFail;
}

include "CodasipMicroClasses.td"

/** Node representing a general call used for all targets generated by Codesip.
 * Note: SDTBrind is used - don't let the name fool you, we simply require pointer type */
def Call: SDNode<"CodasipISD::Call", SDTBrind, [SDNPHasChain,SDNPOptInGlue,SDNPOutGlue,SDNPVariadic]>;
// tail call
def TailCall: SDNode<"CodasipISD::TailCall", SDTBrind, [SDNPHasChain,SDNPOptInGlue,SDNPVariadic]>;

/// Node representing a general return used for all targets generated by Codesip.
def Return: SDNode<"CodasipISD::Ret", SDTNone, [SDNPHasChain,SDNPOptInGlue,SDNPVariadic]>;
// returns from interrupt handlers
def MRet: SDNode<"CodasipISD::MRET", SDTNone, [SDNPHasChain,SDNPOptInGlue,SDNPVariadic]>;
def URet: SDNode<"CodasipISD::URET", SDTNone, [SDNPHasChain,SDNPOptInGlue,SDNPVariadic]>;
def SRet: SDNode<"CodasipISD::SRET", SDTNone, [SDNPHasChain,SDNPOptInGlue,SDNPVariadic]>;

/// Target of a jump (for input operands specification)
def brtarg: Operand<OtherVT>
{
  // note: this should be OPERAND_PCREL but our passes want this
  let OperandType = "OPERAND_IMMEDIATE";
}

/// Wrapper of global symbols
def GAWrap: SDNode<"CodasipISD::GAWrap", SDTIntUnaryOp, []>;
/// Checks names of global symbols
class GAWrapC<int w, int s, int t>: PatFrag<(ops node:$ptr), (GAWrap node:$ptr), "return CheckSymbol(N,"#w#","#s#","#t#");">;

// extended imm operands (pattern nodes)
class immExt<ValueType vt, int w, int s, int t>:
ImmLeaf<vt, "return CheckImm(Imm,"#w#","#s#","#t#");">;
def GAWrap_Trunc12_i32: GAWrapC<32,0,12>;
def Trunc12_i32imm: immExt<i32,32,0,12>;
def GAWrap_sext12To32: GAWrapC<12,1,0>;
def sext12To32imm: immExt<i32,12,1,0>;
def GAWrap_zext5To32: GAWrapC<5,0,0>;
def zext5To32imm: immExt<i32,5,0,0>;


// definitions for indexed load, see SDTIStore
def SDTILoad: SDTypeProfile<2, 2, [SDTCisSameAs<1,2>, SDTCisPtrTy<1>] >;
def ild: SDNode<"ISD::LOAD", SDTILoad, [SDNPHasChain, SDNPMayLoad, SDNPMemOperand]>;

def iload: PatFrag<(ops node:$base, node:$offset), (ild node:$base, node:$offset), [{
  return cast<LoadSDNode>(N)->getExtensionType() == ISD::NON_EXTLOAD;
}]>;
def iextload: PatFrag<(ops node:$base, node:$offset), (ild node:$base, node:$offset), [{
  return cast<LoadSDNode>(N)->getExtensionType() == ISD::EXTLOAD;
}]>;
def isextload: PatFrag<(ops node:$base, node:$offset), (ild node:$base, node:$offset), [{
  return cast<LoadSDNode>(N)->getExtensionType() == ISD::SEXTLOAD;
}]>;
def izextload: PatFrag<(ops node:$base, node:$offset), (ild node:$base, node:$offset), [{
  return cast<LoadSDNode>(N)->getExtensionType() == ISD::ZEXTLOAD;
}]>;

// our own indexed load and store
def pre_inc_load: PatFrag<(ops node:$base, node:$offset), (iload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC;
}]>;
def post_inc_load: PatFrag<(ops node:$base, node:$offset), (iload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC;
}]>;
def pre_dec_load: PatFrag<(ops node:$base, node:$offset), (iload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC;
}]>;
def post_dec_load: PatFrag<(ops node:$base, node:$offset), (iload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC;
}]>;

def pre_inc_store: PatFrag<(ops node:$val, node:$base, node:$offset), (istore node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC;
}]>;
def post_inc_store: PatFrag<(ops node:$val, node:$base, node:$offset), (istore node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC;
}]>;
def pre_dec_store: PatFrag<(ops node:$val, node:$base, node:$offset), (istore node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC;
}]>;
def post_dec_store: PatFrag<(ops node:$val, node:$base, node:$offset), (istore node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC;
}]>;

// custom extloads and truncstores


// combinations of indexed extloads/truncstores

def pre_inc_extloadi8: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_inc_extloadi8: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def pre_dec_extloadi8: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_dec_extloadi8: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;

def pre_inc_sextloadi8: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_inc_sextloadi8: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def pre_dec_sextloadi8: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_dec_sextloadi8: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;

def pre_inc_zextloadi8: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_inc_zextloadi8: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def pre_dec_zextloadi8: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_dec_zextloadi8: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;

def pre_inc_truncstorei8: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_inc_truncstorei8: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def pre_dec_truncstorei8: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_dec_truncstorei8: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;

def pre_inc_extloadi16: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_inc_extloadi16: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def pre_dec_extloadi16: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_dec_extloadi16: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;

def pre_inc_sextloadi16: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_inc_sextloadi16: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def pre_dec_sextloadi16: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_dec_sextloadi16: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;

def pre_inc_zextloadi16: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_inc_zextloadi16: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def pre_dec_zextloadi16: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_dec_zextloadi16: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;

def pre_inc_truncstorei16: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_inc_truncstorei16: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def pre_dec_truncstorei16: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_dec_truncstorei16: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;


// loads and stores with various alignments and for various types
class CodasipLoadStore<dag ops, dag frag, int a, int s>:
PatFrag<ops,frag, "return CheckLoadStore(cast<MemSDNode>(N),"#a#","#s#");">;
def extloadi16_a1_s0: CodasipLoadStore<(ops node:$ptr), (extloadi16 node:$ptr), 1, 0>;
def extloadi8_a1_s0: CodasipLoadStore<(ops node:$ptr), (extloadi8 node:$ptr), 1, 0>;
def load_a1_s0: CodasipLoadStore<(ops node:$ptr), (load node:$ptr), 1, 0>;
def sextloadi16_a1_s0: CodasipLoadStore<(ops node:$ptr), (sextloadi16 node:$ptr), 1, 0>;
def sextloadi8_a1_s0: CodasipLoadStore<(ops node:$ptr), (sextloadi8 node:$ptr), 1, 0>;
def zextloadi16_a1_s0: CodasipLoadStore<(ops node:$ptr), (zextloadi16 node:$ptr), 1, 0>;
def zextloadi8_a1_s0: CodasipLoadStore<(ops node:$ptr), (zextloadi8 node:$ptr), 1, 0>;
def store_a1_s0: CodasipLoadStore<(ops node:$val, node:$ptr), (store node:$val, node:$ptr), 1, 0>;
def truncstorei16_a1_s0: CodasipLoadStore<(ops node:$val, node:$ptr), (truncstorei16 node:$val, node:$ptr), 1, 0>;
def truncstorei8_a1_s0: CodasipLoadStore<(ops node:$val, node:$ptr), (truncstorei8 node:$val, node:$ptr), 1, 0>;


// FI inhibitors for tied register operands
// (and fixed regs can't be used to eat FI - would cause "node emitted late" assert)
def NotFI_i32_rf_xpr_0: PatLeaf<(i32 rf_xpr_0:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_1: PatLeaf<(i32 rf_xpr_1:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_2: PatLeaf<(i32 rf_xpr_2:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_3: PatLeaf<(i32 rf_xpr_3:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_4: PatLeaf<(i32 rf_xpr_4:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_5: PatLeaf<(i32 rf_xpr_5:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_6: PatLeaf<(i32 rf_xpr_6:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_7: PatLeaf<(i32 rf_xpr_7:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_8: PatLeaf<(i32 rf_xpr_8:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_9: PatLeaf<(i32 rf_xpr_9:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_10: PatLeaf<(i32 rf_xpr_10:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_11: PatLeaf<(i32 rf_xpr_11:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_12: PatLeaf<(i32 rf_xpr_12:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_13: PatLeaf<(i32 rf_xpr_13:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_14: PatLeaf<(i32 rf_xpr_14:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_15: PatLeaf<(i32 rf_xpr_15:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_16: PatLeaf<(i32 rf_xpr_16:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_17: PatLeaf<(i32 rf_xpr_17:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_18: PatLeaf<(i32 rf_xpr_18:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_19: PatLeaf<(i32 rf_xpr_19:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_20: PatLeaf<(i32 rf_xpr_20:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_21: PatLeaf<(i32 rf_xpr_21:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_22: PatLeaf<(i32 rf_xpr_22:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_23: PatLeaf<(i32 rf_xpr_23:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_24: PatLeaf<(i32 rf_xpr_24:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_25: PatLeaf<(i32 rf_xpr_25:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_26: PatLeaf<(i32 rf_xpr_26:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_27: PatLeaf<(i32 rf_xpr_27:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_28: PatLeaf<(i32 rf_xpr_28:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_29: PatLeaf<(i32 rf_xpr_29:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_30: PatLeaf<(i32 rf_xpr_30:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_rf_xpr_31: PatLeaf<(i32 rf_xpr_31:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_i32_xpr_general: PatLeaf<(i32 xpr_general:$r), "return !FrameIndexSDNode::classof(N);">;
def CheckFI_i32_xpr_general: PatLeaf<(i32 xpr_general:$r), "return CheckFI(N, Codasip::xpr_generalRegClassID);">;


// vector shuffles


// immediate operands
// note: brtarg versions should be OPERAND_PCREL but our passes want this
let OperandType = "OPERAND_IMMEDIATE" in
{
def MI5valueIH1_13default_start7_5uimm53imm1_5uimm5_i32: Operand<i32>
{
 let EncoderMethod = "encodeMI5valueIH1_13default_start7_5uimm53imm1_5uimm5";
}
def MI5valueIH1_13default_start7_5uimm53imm1_5uimm5_iAny: Operand<iAny>
{
 let EncoderMethod = "encodeMI5valueIH1_13default_start7_5uimm53imm1_5uimm5";
}
def MI5valueIH1_13default_start7_5uimm53imm1_5uimm5_brtarg: Operand<OtherVT>{
 let EncoderMethod = "encodeMI5valueIH1_13default_start7_5uimm53imm1_5uimm5";
}

def MI5valueIH1_13default_start8_6simm124simm1_6simm12_i32: Operand<i32>
{
 let EncoderMethod = "encodeMI5valueIH1_13default_start8_6simm124simm1_6simm12";
}
def MI5valueIH1_13default_start8_6simm124simm1_6simm12_iAny: Operand<iAny>
{
 let EncoderMethod = "encodeMI5valueIH1_13default_start8_6simm124simm1_6simm12";
}
def MI5valueIH1_13default_start8_6simm124simm1_6simm12_brtarg: Operand<OtherVT>{
 let EncoderMethod = "encodeMI5valueIH1_13default_start8_6simm124simm1_6simm12";
}

def MI5valueIH1_13default_start8_6uimm203imm1_6uimm20_i32: Operand<i32>
{
 let EncoderMethod = "encodeMI5valueIH1_13default_start8_6uimm203imm1_6uimm20";
}
def MI5valueIH1_13default_start8_6uimm203imm1_6uimm20_iAny: Operand<iAny>
{
 let EncoderMethod = "encodeMI5valueIH1_13default_start8_6uimm203imm1_6uimm20";
}
def MI5valueIH1_13default_start8_6uimm203imm1_6uimm20_brtarg: Operand<OtherVT>{
 let EncoderMethod = "encodeMI5valueIH1_13default_start8_6uimm203imm1_6uimm20";
}

def MI6addr12IH1_13default_start18_15relative_addr123imm1_15relative_addr12_i32: Operand<i32>
{
 let EncoderMethod = "encodeMI6addr12IH1_13default_start18_15relative_addr123imm1_15relative_addr12";
 let DecoderMethod = "decodeMI6addr12IH1_13default_start18_15relative_addr123imm1_15relative_addr12";
}
def MI6addr12IH1_13default_start18_15relative_addr123imm1_15relative_addr12_iAny: Operand<iAny>
{
 let EncoderMethod = "encodeMI6addr12IH1_13default_start18_15relative_addr123imm1_15relative_addr12";
 let DecoderMethod = "decodeMI6addr12IH1_13default_start18_15relative_addr123imm1_15relative_addr12";
}
def MI6addr12IH1_13default_start18_15relative_addr123imm1_15relative_addr12_brtarg: Operand<OtherVT>{
 let EncoderMethod = "encodeMI6addr12IH1_13default_start18_15relative_addr123imm1_15relative_addr12";
 let DecoderMethod = "decodeMI6addr12IH1_13default_start18_15relative_addr123imm1_15relative_addr12";
}

def MI6addr12IH1_13default_start18_15relative_addr124simm1_15relative_addr12_i32: Operand<i32>
{
 let EncoderMethod = "encodeMI6addr12IH1_13default_start18_15relative_addr124simm1_15relative_addr12";
 let DecoderMethod = "decodeMI6addr12IH1_13default_start18_15relative_addr124simm1_15relative_addr12";
}
def MI6addr12IH1_13default_start18_15relative_addr124simm1_15relative_addr12_iAny: Operand<iAny>
{
 let EncoderMethod = "encodeMI6addr12IH1_13default_start18_15relative_addr124simm1_15relative_addr12";
 let DecoderMethod = "decodeMI6addr12IH1_13default_start18_15relative_addr124simm1_15relative_addr12";
}
def MI6addr12IH1_13default_start18_15relative_addr124simm1_15relative_addr12_brtarg: Operand<OtherVT>{
 let EncoderMethod = "encodeMI6addr12IH1_13default_start18_15relative_addr124simm1_15relative_addr12";
 let DecoderMethod = "decodeMI6addr12IH1_13default_start18_15relative_addr124simm1_15relative_addr12";
}

def MI6addr20IH1_13default_start18_15relative_addr204simm1_15relative_addr20_i32: Operand<i32>
{
 let EncoderMethod = "encodeMI6addr20IH1_13default_start18_15relative_addr204simm1_15relative_addr20";
 let DecoderMethod = "decodeMI6addr20IH1_13default_start18_15relative_addr204simm1_15relative_addr20";
}
def MI6addr20IH1_13default_start18_15relative_addr204simm1_15relative_addr20_iAny: Operand<iAny>
{
 let EncoderMethod = "encodeMI6addr20IH1_13default_start18_15relative_addr204simm1_15relative_addr20";
 let DecoderMethod = "decodeMI6addr20IH1_13default_start18_15relative_addr204simm1_15relative_addr20";
}
def MI6addr20IH1_13default_start18_15relative_addr204simm1_15relative_addr20_brtarg: Operand<OtherVT>{
 let EncoderMethod = "encodeMI6addr20IH1_13default_start18_15relative_addr204simm1_15relative_addr20";
 let DecoderMethod = "decodeMI6addr20IH1_13default_start18_15relative_addr204simm1_15relative_addr20";
}


} //OPERAND_IMMEDIATE

// subtarget feature predicates

